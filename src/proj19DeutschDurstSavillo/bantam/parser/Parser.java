/*
 * Authors: Haoyu Song and Dale Skrien
 * Date: Spring and Summer, 2018
 *
 * In the grammar below, the variables are enclosed in angle brackets.
 * The notation "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable.
 * All other symbols in the rules are terminals.
 * EMPTY indicates a rule with an empty right hand side.
 * All other terminal symbols that are in all caps correspond to keywords.
 *
 * --------------------------------------------------------------------
 * Modification for CS361 Project 10
 * Authors: Zena Abulhab, Yi Feng, Melody Mao, Evan Savillo
 * Date: Dec 6, 2018
 *
 */

package proj19DeutschDurstSavillo.bantam.parser;

import proj19DeutschDurstSavillo.bantam.ast.*;
import proj19DeutschDurstSavillo.bantam.lexer.Scanner;
import proj19DeutschDurstSavillo.bantam.lexer.Token;
import proj19DeutschDurstSavillo.bantam.util.CompilationException;
import proj19DeutschDurstSavillo.bantam.util.Error;
import proj19DeutschDurstSavillo.bantam.util.ErrorHandler;

import static proj19DeutschDurstSavillo.bantam.lexer.Token.Kind.*;


/**
 * This class constructs an AST from a legal Bantam Java program.  If the
 * program is illegal, then one or more error messages are displayed.
 */
public class Parser {
    // instance variables
    private Scanner scanner;
    private Token currentToken; // the lookahead token
    private ErrorHandler errorHandler;
    private String filename;

    // constructor
    public Parser(ErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
        this.scanner = new Scanner(errorHandler);
    }

    /**
     * Test code for Parser
     */
    public static void main(String[] args) {
        //make sure at least one filename was given
        if (args.length < 1) {
            System.err.println("Missing input filename");
            System.exit(-1);
        }

        //for each file given, parse
        ErrorHandler errorHandler = new ErrorHandler();
        for (String filename : args) {
            System.out.println("Scanning and Parsing file: " + filename + "\n");

            //parse tokens
            try {
                Parser parser = new Parser(errorHandler);
                parser.parse(filename);
            } catch (CompilationException e) {
                errorHandler.register(Error.Kind.LEX_ERROR, "Failed parse");
            }

            //check for errors
            if (errorHandler.errorsFound()) {
                errorHandler.getErrorList().forEach(error -> System.out.println(error.toString()));
                System.out.println(String.format("\n%d errors found", errorHandler.getErrorList().size()));
            } else {
                System.out.println("\nParsing successful");
            }

            System.out.println("-----------------------------------------------");

            //clear errors to parse next file
            errorHandler.clear();
        }
    }

    /**
     * parse the given file and return the root node of the AST
     *
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename) {
        this.scanner.setSourceFile(filename);
        this.scanPastCommentary();
        this.filename = filename;

        return parseProgram();
    }

    /*
     * <Program> ::= <Class> | <Class> <Program>
     */
    private Program parseProgram() {
        int position = this.currentToken.position;
        ClassList classList = new ClassList(position);

        while (currentToken.kind != EOF) {
            Class_ aClass = parseClass();
            classList.addElement(aClass);
        }

        return new Program(position, classList);
    }

    /**
     * advance to the next token, ignoring comments
     */
    private void scanPastCommentary() {
        this.currentToken = this.scanner.scan();

        while (this.currentToken.kind == COMMENT) {
            this.currentToken = this.scanner.scan();
        }
    }

    /*
     * <Class> ::= CLASS <Identifier> <ExtendsClause> { <MemberList> }
     * <ExtendsClause> ::= EXTENDS <Identifier> | EMPTY
     * <MemberList> ::= EMPTY | <Member> <MemberList>
     */
    private Class_ parseClass() {
        int initialPosition = this.currentToken.position;
        String className = "";
        String parent = "";
        MemberList memberList = new MemberList(initialPosition);

        if (this.currentToken.kind == CLASS) {
            this.scanPastCommentary();
            if (this.currentToken.kind == IDENTIFIER) {
                className = this.currentToken.spelling;
            } else {
                this.whinge("Expecting valid class name in class declaration.");
            }

            this.scanPastCommentary();
            if (this.currentToken.kind == EXTENDS) {
                this.scanPastCommentary();
                if (this.currentToken.kind == IDENTIFIER) {
                    parent = this.currentToken.spelling;
                    this.scanPastCommentary();
                } else {
                    this.whinge("Missing name of class to extend in class declaration.");
                }
            }

            if (this.currentToken.kind != LCURLY) {
                this.whinge("Expected left brace.");
            }

            this.scanPastCommentary();
            while (this.currentToken.kind != RCURLY) {
                Member member = parseMember();
                memberList.addElement(member);
            }

            this.scanPastCommentary();
        }

        else {
            this.whinge("Expected \"class\"");
        }

        return new Class_(initialPosition, className, className, parent, memberList);
    }

    /* Fields and Methods
     * <Member> ::= <Field> | <Method>
     * <Method> ::= <Type> <Identifier> ( <Parameters> ) <Block>
     * <Field> ::= <Type> <Identifier> <InitialValue> ;
     * <InitialValue> ::= EMPTY | = <Expression>
     */
    private Member parseMember() {
        int position = this.currentToken.position;
        String type = this.parseType();
        String nameIdentifier = this.parseIdentifier();
        Member member = null;

        //if member matches form for a method
        if (this.currentToken.kind == LPAREN) {
            this.scanPastCommentary();
            FormalList params = this.parseParameters();

            //check for closing parenthesis
            if (this.currentToken.kind != RPAREN) {
                this.whinge("Missing closing parenthesis in method declaration.");
            } else //if present, move on to next token
            {
                this.scanPastCommentary();
            }

            BlockStmt block = (BlockStmt) this.parseBlock();
            StmtList blockStmts = block.getStmtList();

            member = new Method(position, type, nameIdentifier,
                    params, blockStmts);
        } else //otherwise parse member as field
        {
            if (this.currentToken.kind == SEMICOLON) {
                //empty initial value
                member = new Field(position, type, nameIdentifier, null);
            } else if (this.currentToken.kind == ASSIGN) {
                //non-empty initial value
                this.scanPastCommentary(); //read past =
                Expr initValueExpr = this.parseExpression();

                //check for semicolon
                if (this.currentToken.kind != SEMICOLON) {
                    this.whinge("Missing ending semicolon in field declaration.");
                } else {
                    member = new Field(position, type, nameIdentifier, initValueExpr);
                }
            } else {
                //invalid syntax
                this.whinge("Invalid field declaration.");
            }

            //move past ending semicolon
            this.scanPastCommentary();
        }

        return member;
    }

    //-----------------------------------

    /*
     * <BlockStmt> ::= { <Body> }
     * <Body> ::= EMPTY | <Stmt> <Body>
     */
    private Stmt parseBlock() {
        int lineNum = this.currentToken.position;
        BlockStmt blockStmt = null;

        if (this.currentToken.kind != LCURLY)
            this.whinge("Expected opening brace");

        this.scanPastCommentary();

        StmtList stmtList = new StmtList(lineNum);
        while (this.currentToken.kind != RCURLY) {

            if (this.currentToken.kind == EOF)
                this.whinge("Expected closing brace");

            Stmt stmt = parseStatement();
            stmtList.addElement(stmt);
        }
        blockStmt = new BlockStmt(lineNum, stmtList);

        this.scanPastCommentary();

        return blockStmt;
    }

    /*
     * <Expression> ::= <LogicalOrExpr> <OptionalAssignment>
     * <OptionalAssignment> ::= EMPTY | = <Expression>
     */
    private Expr parseExpression() {
        int lineNum = this.currentToken.position;
        Expr expr = parseOrExpr();

        // if optional assignment present
        if (this.currentToken.kind == ASSIGN) {
            //left-hand side of assignment must be a var or array expr
            if (expr instanceof VarExpr) {
                String name = ((VarExpr) (expr)).getName();
                Expr ref = ((VarExpr) (expr)).getRef();

                //if ref is given, get its name
                String refName = null;
                if (ref != null) {
                    //make sure ref is a VarExpr
                    if (!(ref instanceof VarExpr))
                        this.whinge("Expected var expression");

                    refName = ((VarExpr) ref).getName();
                }

                this.scanPastCommentary(); //move past ASSIGN
                Expr assignedExpr = parseExpression();

                expr = new AssignExpr(lineNum, refName, name, assignedExpr);
            } else if (expr instanceof ArrayExpr) {
                String name = ((ArrayExpr) (expr)).getName();
                Expr ref = ((ArrayExpr) (expr)).getRef();
                Expr indexExpr = ((ArrayExpr) (expr)).getIndex();

                //if ref is given, get its name
                String refName = null;
                if (ref != null) {
                    //make sure ref is a VarExpr
                    if (!(ref instanceof VarExpr))
                        this.whinge("Expected var expression");

                    refName = ((VarExpr) ref).getName();
                }

                this.scanPastCommentary(); //move past ASSIGN
                Expr assignedExpr = parseExpression();

                expr = new ArrayAssignExpr(lineNum, refName, name, indexExpr, assignedExpr);
            } else
                this.whinge("Expected var or array expression to which to assign");
        }

        return expr;
    }

     /*
     * <Closure>  ::= EMPTY | this | super
     */
    private Closure parseClosures() {
        int lineNum = this.currentToken.position;
        Closure closure = new Closure(lineNum);

        if (this.currentToken.kind == RBRACKET)
            return closure;

        String identifier = parseIdentifier();
       
        if (!identifier.equals("this") && !identifier.equals("super"))
            this.whinge("Unexpected variable enclosed in lambda definition. Only legal values are 'this' or 'super'.");
        
        VarExpr varExpr = new VarExpr(lineNum, null, identifier);
        closure.addElement(varExpr);

        if (this.currentToken.kind != RBRACKET)
            this.whinge("Expected closing bracket. **Note** can have at most one input to lambda closure.");

        return closure;
    }

    /*
     * <Parameters>  ::= EMPTY | <Formal> <MoreFormals>
     * <MoreFormals> ::= EMPTY | , <Formal> <MoreFormals>
     */
    private FormalList parseParameters() {
        int lineNum = this.currentToken.position;
        FormalList formalList = new FormalList(lineNum);

        if (this.currentToken.kind == RPAREN)
            return formalList;

        formalList.addElement(this.parseFormal());

        // check any parameters that may be present
        while (this.currentToken.kind == COMMA) {

            this.scanPastCommentary();
            Formal formal = parseFormal();
            formalList.addElement(formal);
        }

        return formalList;
    }

    /*
     * <Type> ::= <Identifier> <Brackets>
     * <Brackets> ::= EMPTY | [ ]
     * <LambSign> ::= EMPTY | (<Type>*)
     */
    private String parseType() {
        String type = parseIdentifier();

        if (currentToken.kind == LBRACKET) // check for brackets
        {
            this.scanPastCommentary();

            if (currentToken.kind != RBRACKET)
                this.whinge("Expected closing bracket.");

            type += "[]";

            this.scanPastCommentary();
        }

        /**
         * define the type of LambSigns as:
         *  
         *      _RETURN_TYPE([FORMAL_TYPE][, FORMAL_TYPE]*)
         */
        if (currentToken.kind == LARROW)
        {
            type = "_" + type + "(";

            // consume LARROW
            this.scanPastCommentary();

            // check for LPAREN
            if (currentToken.kind != LPAREN)
                this.whinge("Expected opening bracket.");
            else
                this.scanPastCommentary();

            if (this.currentToken.kind == RPAREN) {
                this.scanPastCommentary();
                return type += ")";
            }

            String formalType = parseIdentifier();
            // check for array type
            if (currentToken.kind == LBRACKET)
            {
                this.scanPastCommentary();

                if (currentToken.kind != RBRACKET)
                    this.whinge("Expected closing bracket.");

                    type += formalType + "[]";

                this.scanPastCommentary();
            }
            else {
                type += formalType;
            }

            while(currentToken.kind == COMMA)
            {
               this.scanPastCommentary();
                formalType = parseIdentifier();
                // check for array type
                if (currentToken.kind == LBRACKET) 
                {
                    this.scanPastCommentary();

                    if (currentToken.kind != RBRACKET)
                        this.whinge("Expected closing bracket.");

                        type += "," + formalType + "[]";

                    this.scanPastCommentary();
                }
                else {
                    type += "," + formalType;
                }
               
            }
            
            if (currentToken.kind != RPAREN)
                this.whinge("Expected closing bracket.");

            this.scanPastCommentary();

            type += ")";
        }

        return type;
    }

    private String parseIdentifier() {
        if (this.currentToken.kind != IDENTIFIER)
            this.whinge("Expected identifier.");

        String identifier = this.currentToken.getSpelling();

        this.scanPastCommentary();

        return identifier;
    }

    /* Statements
     *  <Stmt> ::= <WhileStmt> | <ReturnStmt> | <BreakStmt> | <DeclStmt>
     *              | <ExpressionStmt> | <ForStmt> | <BlockStmt> | <IfStmt>
     */
    private Stmt parseStatement() {
        Stmt stmt;

        switch (currentToken.kind) {
            case IF:
                stmt = parseIf();
                break;
            case LCURLY:
                stmt = parseBlock();
                break;
            case VAR:
                stmt = parseDeclStmt();
                break;
            case RETURN:
                stmt = parseReturn();
                break;
            case FOR:
                stmt = parseFor();
                break;
            case WHILE:
                stmt = parseWhile();
                break;
            case BREAK:
                stmt = parseBreak();
                break;
            default:
                stmt = parseExpressionStmt();
        }

        return stmt;
    }

    /*
     * <WhileStmt> ::= WHILE ( <Expression> ) <Stmt>
     */
    private Stmt parseWhile() {
        int lineNum = this.currentToken.position;

        this.scanPastCommentary();
        if (this.currentToken.kind == LPAREN) {
            this.scanPastCommentary();
            Expr expr = parseExpression();

            if (this.currentToken.kind == RPAREN) {
                this.scanPastCommentary();
                Stmt stmt = parseStatement();

                return new WhileStmt(lineNum, expr, stmt);
            } else
                this.whinge("Expected closing parenthesis");
        } else
            this.whinge("Expected opening parenthesis");

        return null;
    }

    /*
     * <ReturnStmt> ::= RETURN <Expression> ; | RETURN ;
     */
    private Stmt parseReturn() {
        Expr expr = null;
        int lineNum = this.currentToken.position;

        this.scanPastCommentary();
        if (this.currentToken.kind != SEMICOLON) {
            expr = parseExpression();
            checkSemicolon();
        } else {
            this.scanPastCommentary();
        }

        return new ReturnStmt(lineNum, expr);
    }

    /*
     * BreakStmt> ::= BREAK ;
     */
    private Stmt parseBreak() {
        int lineNum = this.currentToken.position;
        this.scanPastCommentary();
        checkSemicolon();

        return new BreakStmt(lineNum);
    }

    //-----------------------------------------
    // Expressions
    //Here we introduce the precedence to operations

    /*
     * <ExpressionStmt> ::= <Expression> ;
     */
    private ExprStmt parseExpressionStmt() {
        int lineNum = this.currentToken.position;
        Expr expr = parseExpression();
        this.checkSemicolon();

        return new ExprStmt(lineNum, expr);
    }

    /*
     * <DeclStmt> ::= VAR <Identifier> = <Expression> ;
     * every local variable must be initialized
     */
    private Stmt parseDeclStmt() {
        int lineNum = this.currentToken.position;

        this.scanPastCommentary();
        if (this.currentToken.kind == IDENTIFIER) {
            String identifier = parseIdentifier();

            if (this.currentToken.kind == ASSIGN) {
                this.scanPastCommentary();
                Expr expr = parseExpression();
                this.checkSemicolon();

                return new DeclStmt(lineNum, identifier, expr);
            } else
                whinge("Expected assignment sign");
        } else
            whinge("Expected identifier");

        return null;
    }

    /*
     * <ForStmt> ::= FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
     * <Start>     ::= EMPTY | <Expression>
     * <Terminate> ::= EMPTY | <Expression>
     * <Increment> ::= EMPTY | <Expression>
     */
    private Stmt parseFor() {
        Expr start = null;
        Expr terminate = null;
        Expr increment = null;

        int lineNum = this.currentToken.position;

        this.scanPastCommentary();
        if (this.currentToken.kind != LPAREN)
            this.whinge("Expected opening parenthesis");

        this.scanPastCommentary();
        if (this.currentToken.kind != SEMICOLON) {
            start = parseExpression();
            this.checkSemicolon();
        } else
            this.scanPastCommentary();

        if (this.currentToken.kind != SEMICOLON) {
            terminate = parseExpression();
            this.checkSemicolon();
        } else
            this.scanPastCommentary();

        if (this.currentToken.kind != RPAREN) {
            increment = parseExpression();

            if (this.currentToken.kind != RPAREN)
                this.whinge("Expected closing parenthesis");
            else
                this.scanPastCommentary();
        } else
            this.scanPastCommentary();

        Stmt bodyStmt = parseStatement();

        return new ForStmt(lineNum, start, terminate, increment, bodyStmt);
    }

    /*
     * <IfStmt> ::= IF ( <Expr> ) <Stmt> | IF ( <Expr> ) <Stmt> ELSE <Stmt>
     */
    private Stmt parseIf() {
        Expr expr = null;
        Stmt thenStmt = null;
        Stmt elseStmt = null;

        int lineNum = currentToken.position;

        this.scanPastCommentary();
        if (this.currentToken.kind != LPAREN)
            this.whinge("Expected opening parenthesis");

        this.scanPastCommentary();
        expr = parseExpression();

        if (this.currentToken.kind != RPAREN)
            this.whinge("Expected closing parenthesis");

        this.scanPastCommentary();
        thenStmt = parseStatement();

        if (this.currentToken.kind == ELSE) {
            this.scanPastCommentary();
            elseStmt = parseStatement();
        }

        return new IfStmt(lineNum, expr, thenStmt, elseStmt);
    }

    /*
     * <LogicalOR> ::= <logicalAND> <LogicalORRest>
     * <LogicalORRest> ::= EMPTY |  || <LogicalAND> <LogicalORRest>
     */
    private Expr parseOrExpr() {
        int lineNum = this.currentToken.position;

        Expr left = parseAndExpr();
        while (this.currentToken.spelling.equals("||")) {
            this.scanPastCommentary();
            Expr right = parseAndExpr();
            left = new BinaryLogicOrExpr(lineNum, left, right);
        }

        return left;
    }

    /*
     * <LogicalAND> ::= <ComparisonExpr> <LogicalANDRest>
     * <LogicalANDRest> ::= EMPTY |  && <ComparisonExpr> <LogicalANDRest>
     */
    private Expr parseAndExpr() {
        int lineNum = currentToken.position;

        Expr left = parseEqualityExpr();
        while (this.currentToken.spelling.equals("&&")) {
            this.scanPastCommentary();
            Expr right = parseEqualityExpr();
            left = new BinaryLogicAndExpr(lineNum, left, right);
        }

        return left;
    }

    /*
     * <ComparisonExpr> ::= <RelationalExpr> <equalOrNotEqual> <RelationalExpr> |
     *                     <RelationalExpr>
     * <equalOrNotEqual> ::=  == | !=
     */
    private Expr parseEqualityExpr() {
        int lineNum = currentToken.position;
        Expr left = parseRelationalExpr();
        Expr right = null;
        Expr expr = null;

        if (this.currentToken.spelling.equals("==")) {
            this.scanPastCommentary();
            right = parseRelationalExpr();
            expr = new BinaryCompEqExpr(lineNum, left, right);
        } else if (this.currentToken.spelling.equals("!=")) {
            this.scanPastCommentary();
            right = parseRelationalExpr();
            expr = new BinaryCompNeExpr(lineNum, left, right);
        } else {
            expr = left;
        }

        return expr;
    }

    /*
     * <RelationalExpr> ::=<AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
     * <ComparisonOp> ::=  < | > | <= | >= | INSTANCEOF
     */
    private Expr parseRelationalExpr() {
        int lineNum = this.currentToken.position;
        Expr left = parseAddExpr();
        Expr right = null;
        Expr expr = null;

        switch (this.currentToken.spelling) {
            case "<":
                this.scanPastCommentary();
                right = parseAddExpr();
                expr = new BinaryCompLtExpr(lineNum, left, right);
                break;
            case ">":
                this.scanPastCommentary();
                right = parseAddExpr();
                expr = new BinaryCompGtExpr(lineNum, left, right);
                break;
            case "<=":
                this.scanPastCommentary();
                right = parseAddExpr();
                expr = new BinaryCompLeqExpr(lineNum, left, right);
                break;
            case ">=":
                this.scanPastCommentary();
                right = parseAddExpr();
                expr = new BinaryCompGeqExpr(lineNum, left, right);
                break;
            case "instanceof":
                this.scanPastCommentary();
                String type = parseType();
                expr = new InstanceofExpr(lineNum, left, type);
                break;
            default:
                expr = left;
        }

        return expr;
    }

    /*
     * <AddExpr>::＝ <MultExpr> <MoreMultExpr>
     * <MoreMultExpr> ::= EMPTY | + <MultExpr> <MoreMultExpr> | - <MultExpr> <MoreMultExpr>
     */
    private Expr parseAddExpr() {
        int lineNum = currentToken.position;

        Expr left = parseMultExpr();
        while (this.currentToken.kind == PLUSMINUS) {
            if (this.currentToken.spelling.equals("+")) {
                this.scanPastCommentary();
                Expr right = parseMultExpr();
                left = new BinaryArithPlusExpr(lineNum, left, right);
            } else if (this.currentToken.spelling.equals("-")) {
                this.scanPastCommentary();
                Expr right = parseMultExpr();
                left = new BinaryArithMinusExpr(lineNum, left, right);
            }
        }
        return left;
    }

    /*
     * <MultiExpr> ::= <NewCastOrUnary> <MoreNCU>
     * <MoreNCU> ::= * <NewCastOrUnary> <MoreNCU> |
     *               / <NewCastOrUnary> <MoreNCU> |
     *               % <NewCastOrUnary> <MoreNCU> |
     *               EMPTY
     */
    private Expr parseMultExpr() {
        int lineNum = this.currentToken.position;
        Expr result = this.parseNewCastOrUnary();

        //build rest of MultiExpr while there are more operands
        Expr right;
        while (this.currentToken.kind == MULDIV) {
            switch (this.currentToken.spelling) {
                case "*":
                    //multiply
                    this.scanPastCommentary();
                    right = this.parseNewCastOrUnary();
                    result = new BinaryArithTimesExpr(lineNum, result, right);
                    break;
                case "/":
                    //divide
                    this.scanPastCommentary();
                    right = this.parseNewCastOrUnary();
                    result = new BinaryArithDivideExpr(lineNum, result, right);
                    break;
                case "%":
                    //modulo
                    this.scanPastCommentary();
                    right = this.parseNewCastOrUnary();
                    result = new BinaryArithModulusExpr(lineNum, result, right);
                    break;
            }
        }

        return result;
    }

    /*
     * <NewCastLambdaOrUnary> ::= <NewExpression> | <CastExpression> | <LambdaExpr> | <UnaryPrefix>
     */
    private Expr parseNewCastOrUnary() {
        Expr expr;
        //determine which rule to follow based on first token
        if (this.currentToken.kind == NEW) {
            expr = this.parseNew();
        } else if (this.currentToken.kind == CAST) {
            expr = this.parseCast();
        } else if (this.currentToken.kind == LBRACKET) {
            expr = this.parseLambda();
        } else {
            expr = this.parseUnaryPrefix();
        }
        return expr;
    }

    /*
     * <LambdaExpr> ::= <Closure> ( <Parameters> ) <Type> <Block>
     */
    private LambdaExpr parseLambda() {
        this.scanPastCommentary(); //move past [

        int position = this.currentToken.position;

        Closure closure = this.parseClosures();

        this.scanPastCommentary(); //move past ]

        //check for opening parenthesis
        if (this.currentToken.kind != LPAREN) {
            this.whinge("Missing opening parenthesis in lambda expression declaration.");
        } else //if present, move on to next token
        {
            this.scanPastCommentary();
        }

        FormalList params = this.parseParameters();

        //check for closing parenthesis
        if (this.currentToken.kind != RPAREN) {
            this.whinge("Missing closing parenthesis in lambda expression declaration.");
        } else //if present, move on to next token
        {
            this.scanPastCommentary();
        }

        //check for rarrow
        if (this.currentToken.kind != RARROW) {
            this.whinge("Missing right arrow in lambda expression declaration.");
        } else //if present, move on to next token
        {
            this.scanPastCommentary();
        }

        String type = this.parseType();

        BlockStmt block = (BlockStmt) this.parseBlock();
        StmtList blockStmts = block.getStmtList();

        LambdaExpr lambdaExpr = new LambdaExpr(position, type, params, closure, blockStmts);

        return lambdaExpr;
    } 

    /*
     * <NewExpression> ::= NEW <Identifier> ( ) | NEW <Identifier> [ <Expression> ]
     */
    private Expr parseNew() {
        int lineNum = this.currentToken.position;
        Expr result = null;

        this.scanPastCommentary(); //move past NEW
        String type = this.parseIdentifier();

        //handle new object
        if (this.currentToken.kind == LPAREN) {
            result = new NewExpr(lineNum, type);

            //check for closing parenthesis
            this.scanPastCommentary();
            if (this.currentToken.kind != RPAREN) {
                this.whinge("Expected closing parenthesis in new object expression");
            } else {
                this.scanPastCommentary();
            }
        }
        //handle new array
        else if (this.currentToken.kind == LBRACKET) {
            this.scanPastCommentary();
            Expr size = this.parseExpression();

            result = new NewArrayExpr(lineNum, type, size);

            //check for closing bracket
            if (this.currentToken.kind != RBRACKET) {
                this.whinge("Expected closing bracket in new array expression");
            } else {
                this.scanPastCommentary();
            }
        } else {
            this.whinge("Invalid new object/array expression");
        }

        return result;
    }

    /*
     * <CastExpression> ::= CAST ( <Type> , <Expression> )
     */
    private Expr parseCast() {
        int lineNum = this.currentToken.position;
        Expr result = null;

        this.scanPastCommentary(); //scan past CAST
        if (this.currentToken.kind != LPAREN)
            this.whinge("Expected opening parenthesis in cast expression");

        this.scanPastCommentary(); //scan past (
        String type = this.parseType();

        //check for comma
        if (this.currentToken.kind != COMMA)
            this.whinge("Expected comma in cast expression");
        this.scanPastCommentary(); //scan past ,

        Expr castedExpr = this.parseExpression();
        result = new CastExpr(lineNum, type, castedExpr);

        //check for closing parenthesis
        if (this.currentToken.kind != RPAREN)
            this.whinge("Expected closing parenthesis in cast expression");

        this.scanPastCommentary(); //scan past )

        return result;
    }

    /*
     * <UnaryPrefix> ::= <PrefixOp> <UnaryPrefix> | <UnaryPostfix>
     * <PrefixOp> ::= - | ! | ++ | --
     */
    private Expr parseUnaryPrefix() {
        int lineNum = this.currentToken.position;
        Expr result = null;

        switch (this.currentToken.kind) {
            case PLUSMINUS:
                //unary negation

                //check to make sure not +
                if (this.currentToken.spelling.equals("+"))
                    this.whinge("Unexpected + prefix to expression");
                else {
                    this.scanPastCommentary();
                    Expr innerPrefix = this.parseUnaryPrefix();
                    result = new UnaryNegExpr(lineNum, innerPrefix);
                }
                break;
            case UNARYNOT: {
                //unary not
                this.scanPastCommentary();
                Expr innerPrefix = this.parseUnaryPrefix();
                result = new UnaryNotExpr(lineNum, innerPrefix);
                break;
            }
            case UNARYINCR: {
                //pre-increment
                this.scanPastCommentary();
                Expr innerPrefix = this.parseUnaryPrefix();
                result = new UnaryIncrExpr(lineNum, innerPrefix, false);
                break;
            }
            case UNARYDECR: {
                //pre-decrement
                this.scanPastCommentary();
                Expr innerPrefix = this.parseUnaryPrefix();
                result = new UnaryDecrExpr(lineNum, innerPrefix, false);
                break;
            }
            default:
                //no prefix (base case)
                result = this.parseUnaryPostfix();
                break;
        }

        return result;
    }

    /*
     * <UnaryPostfix> ::= <Primary> <PostfixOp>
     * <PostfixOp> ::= ++ | -- | EMPTY
     */
    private Expr parseUnaryPostfix() {
        int lineNum = this.currentToken.position;
        Expr result = null;

        Expr primary = this.parsePrimary();

        if (this.currentToken.kind == UNARYINCR) {
            this.scanPastCommentary();
            //post-increment
            result = new UnaryIncrExpr(lineNum, primary, true);
        } else if (this.currentToken.kind == UNARYDECR) {
            this.scanPastCommentary();
            //post-decrement
            result = new UnaryDecrExpr(lineNum, primary, true);
        } else {
            //no postfix
            result = primary;
        }

        return result;
    }

    /* <Primary> ::= <IntegerConst>
     *             | <BooleanConst>
     *             | <StringConst> <Suffix>
     *             | <Identifier> <Suffix>
     *             | ( <Expression> ) <Suffix>
     */
    private Expr parsePrimary() {
        int lineNum = this.currentToken.position;
        Expr suffix;

        //parse the starting primary
        switch (this.currentToken.kind) {
            case INTCONST:
                return parseIntConst();

            case BOOLEAN:
                return parseBoolean();

            case STRCONST:
                ConstStringExpr stringExpr = parseStringConst();
                suffix = parseSuffix(stringExpr);

                // if there wasn't anything else to parse, just return stringExpr
                if (suffix == null) {
                    return stringExpr;
                } else {
                    return suffix;
                }

            case IDENTIFIER:
                String identifier = parseIdentifier();
                VarExpr varExpr = new VarExpr(lineNum, null, identifier);
                suffix = parseSuffix(varExpr);

                // if there wasn't anything else to parse, just return varExpr
                if (suffix == null) {
                    return varExpr;
                } else {
                    return suffix;
                }

            case LPAREN:
                this.scanPastCommentary();

                Expr expr = parseExpression();

                if (this.currentToken.kind != RPAREN)
                    this.whinge("Expected closing parenthesis in primary");

                this.scanPastCommentary();

                suffix = parseSuffix(expr);

                // if there wasn't anything else to parse, just return expr
                if (suffix == null) {
                    return expr;
                } else {
                    return suffix;
                }

            default:
                this.whinge("Expected primary");
                return null;
        }
    }

    /*  <Suffix> ::= . <Identifier> <Suffix>
     *             | [ <Expression> ] <Suffix>
     *             | ( <Arguments> ) <Suffix>
     *             | EMPTY
     */
    private Expr parseSuffix(Expr prefix) {
        int lineNum = this.currentToken.position;
        Expr suffix = null;

        switch (this.currentToken.kind) {
            case DOT:
                this.scanPastCommentary();

                String identifier = parseIdentifier();

                VarExpr varExpr = new VarExpr(lineNum, prefix, identifier);

                suffix = parseSuffix(varExpr);

                if (suffix == null) {
                    return varExpr;
                }

                break;

            case LBRACKET: // must be an array expr?
                if (prefix instanceof ConstStringExpr)
                    this.whinge("Illegal expression: \"foo\"[...]");
                if (prefix instanceof ArrayExpr)
                    this.whinge("Illegal expression: foo[...][...]");
                if (prefix instanceof DispatchExpr)
                    this.whinge("Illegal expression: foo(...)[...]");

                this.scanPastCommentary();

                Expr index = parseExpression();

                if (this.currentToken.kind != RBRACKET)
                    this.whinge("Expected closing bracket in suffix");

                this.scanPastCommentary();

                Expr ref = ((VarExpr) prefix).getRef();
                String name = ((VarExpr) prefix).getName();

                ArrayExpr arrayExpr = new ArrayExpr(lineNum, ref, name, index);

                suffix = parseSuffix(arrayExpr);

                // if there wasn't anything else to parse, just return what there was, here
                if (suffix == null) {
                    return arrayExpr;
                }

                break;

            case LPAREN: // must be a dispatch expr?
                if (prefix instanceof ConstStringExpr)
                    this.whinge("Illegal expression: \"foo\"(...)");
                if (prefix instanceof ArrayExpr)
                    this.whinge("Illegal expression: foo[...](...)");
                if (prefix instanceof DispatchExpr)
                    this.whinge("Illegal expression: foo(...)(...)");

                this.scanPastCommentary();

                ExprList actualList = parseArguments();

                if (this.currentToken.kind != RPAREN)
                    this.whinge("Expected closing parenthesis in suffix");

                this.scanPastCommentary();

                Expr refExpr = ((VarExpr) prefix).getRef();
                String methodName = ((VarExpr) prefix).getName();

                DispatchExpr dispatchExpr = new DispatchExpr(lineNum, refExpr, methodName, actualList);

                suffix = parseSuffix(dispatchExpr);

                // if there wasn't anything else to parse, just return what there was, here
                if (suffix == null) {
                    return dispatchExpr;
                }

                break;

            default:
                break;
        }

        // just return whatever the parseSuffix gave us (which will include what we parsed here)
        return suffix;
    }

    /*
     * <Arguments> ::= EMPTY | <Expression> <MoreArgs>
     * <MoreArgs>  ::= EMPTY | , <Expression> <MoreArgs>
     */
    private ExprList parseArguments() {
        int lineNum = this.currentToken.position;
        ExprList argList = new ExprList(lineNum);

        if (this.currentToken.kind == RPAREN) {
            return argList;
        }

        //parse first argument
        argList.addElement(this.parseExpression());

        //parse other arguments if present
        while (this.currentToken.kind == COMMA) {
            this.scanPastCommentary(); //move past comma
            argList.addElement(this.parseExpression());
        }

        return argList;
    }

    //----------------------------------------
    //Terminals

    /*
     * <Formal> ::= <Type> <Identifier>
     */
    private Formal parseFormal() {
        int lineNum = this.currentToken.position;
        String type = "";
        String name = "";

        type = parseType();
        
        // ---- ASSUMED TO BE DUPLICATED ---- //
        // if (this.currentToken.kind == IDENTIFIER) {
        //     type = parseIdentifier();
        // } else
        //     this.whinge("Expected valid type name");

        // if (this.currentToken.kind == LBRACKET)  // optional brackets
        // {
        //     this.scanPastCommentary();
        //     if (this.currentToken.kind != RBRACKET)
        //         this.whinge("Expected closing bracket");

        //     type += "[]";
        //     this.scanPastCommentary();
        // }

        if (this.currentToken.kind == IDENTIFIER) {
            name = parseIdentifier();
        } else
            this.whinge("Expected identifier or opening bracket");

        return new Formal(lineNum, type, name);
    }

    private String parseOperator() {
        String operator = this.currentToken.spelling;

        this.scanPastCommentary();

        return operator;
    }

    private ConstStringExpr parseStringConst() {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.scanPastCommentary();

        return new ConstStringExpr(lineNum, constant);
    }


    private ConstIntExpr parseIntConst() {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.scanPastCommentary();

        return new ConstIntExpr(lineNum, constant);
    }


    private ConstBooleanExpr parseBoolean() {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.scanPastCommentary();

        return new ConstBooleanExpr(lineNum, constant);
    }

    /**
     * helper method to check semicolon
     * if the current token is not semicolon, report error
     */
    private void checkSemicolon() {
        if (this.currentToken.kind != SEMICOLON)
            this.whinge("Expected semicolon.");
        this.scanPastCommentary();
    }

    /**
     * register the encountered error to the error handler
     * throw a compilation exception
     *
     * @param errorMessage
     * @throws CompilationException
     */
    private void whinge(String errorMessage)
            throws CompilationException {
        this.errorHandler.register(Error.Kind.PARSE_ERROR,
                this.filename,
                this.currentToken.position,
                errorMessage);
        throw new CompilationException(String.format("Compilation Exception: %s", errorMessage));
    }
}